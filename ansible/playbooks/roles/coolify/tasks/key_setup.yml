---
- name: Create temporary file for key conversion
  ansible.builtin.tempfile:
    state: file
    suffix: _coolify_key
  register: temp_key_file
  delegate_to: localhost
  become: false
  when: not ansible_check_mode

- name: Read local private key
  ansible.builtin.slurp:
    src: "{{ (coolify_private_key_path | expanduser) if coolify_private_key_path.startswith('~') else coolify_private_key_path }}"
  register: local_priv_key
  delegate_to: localhost
  become: false
  when: 
    - not ansible_check_mode
    - coolify_private_key_path != ""

- name: Prepare and normalize private key content
  ansible.builtin.set_fact:
    coolify_private_key_content: "{{ local_priv_key.content | b64decode | replace('\r', '') | trim ~ '\n' }}"
  no_log: true
  when:
    - not ansible_check_mode
    - local_priv_key is defined
    - local_priv_key.content is defined

- name: Convert OPENSSH key to PEM format if needed
  block:
    - name: Write temporary key for conversion
      ansible.builtin.copy:
        content: "{{ coolify_private_key_content }}"
        dest: "{{ temp_key_file.path }}"
        mode: '0600'
      delegate_to: localhost
      become: false

    - name: Check key type for conversion compatibility
      ansible.builtin.shell: |
        set -o pipefail
        ssh-keygen -y -P "" -f "{{ temp_key_file.path }}" | ssh-keygen -l -f -
      register: key_info
      delegate_to: localhost
      become: false
      changed_when: false
      ignore_errors: true

    - name: Warn if Ed25519 key is used
      ansible.builtin.debug:
        msg: "WARNING: Ed25519 key detected. Ed25519 keys do not support legacy PEM format and cannot be converted. If Coolify registration fails, please use an RSA or ECDSA key."
      when: 
        - key_info.rc == 0
        - "'ED25519' in key_info.stdout | upper"

    - name: Convert key using ssh-keygen
      ansible.builtin.command:
        cmd: "ssh-keygen -p -m PEM -f {{ temp_key_file.path }} -N '' -P ''"
      delegate_to: localhost
      become: false
      changed_when: true
      ignore_errors: true
      register: conversion_result
      when: 
        - key_info.rc == 0
        - "'ED25519' not in key_info.stdout | upper"

    - name: Read converted key
      ansible.builtin.slurp:
        src: "{{ temp_key_file.path }}"
      register: converted_key_slurp
      delegate_to: localhost
      become: false
      when: 
        - conversion_result.rc | default(1) == 0

    - name: Update private key content fact if converted
      ansible.builtin.set_fact:
        coolify_private_key_content: "{{ converted_key_slurp.content | b64decode }}"
      no_log: true
      when: 
        - conversion_result is not skipped
        - conversion_result.rc == 0
        - converted_key_slurp is defined
  always:
    - name: Remove temporary key
      ansible.builtin.file:
        path: "{{ temp_key_file.path }}"
        state: absent
      delegate_to: localhost
      become: false
      when: temp_key_file.path is defined
  when:
    - not ansible_check_mode
    - coolify_private_key_content is defined
    - coolify_private_key_content.startswith('-----BEGIN OPENSSH PRIVATE KEY')

- name: List Private Keys from Coolify
  ansible.builtin.uri:
    url: "{{ coolify_api_base_url }}/security/keys"
    method: GET
    headers:
      Authorization: "Bearer {{ coolify_api_token }}"
  register: keys_list
  when: not ansible_check_mode

- name: Find existing key UUID by name ({{ coolify_key_name }})
  ansible.builtin.set_fact:
    coolify_key_uuid: "{{ (keys_list.json | selectattr('name', 'equalto', coolify_key_name) | first).uuid if keys_list is not skipped and keys_list.json is defined and (keys_list.json | selectattr('name', 'equalto', coolify_key_name) | list | length > 0) else '' }}"
  when: not ansible_check_mode

- name: Validate Private Key format
  ansible.builtin.assert:
    that:
      - coolify_private_key_content.startswith('-----BEGIN')
    fail_msg: "The local private key at {{ coolify_private_key_path }} does not appear to be a valid PEM-formatted private key (missing '-----BEGIN' header)."
  when:
    - not ansible_check_mode
    - coolify_key_uuid == ""
    - coolify_private_key_content is defined

- name: Debug existing key names
  ansible.builtin.debug:
    msg: "Found keys: {{ keys_list.json | map(attribute='name') | list }}"
  when: 
    - not ansible_check_mode
    - keys_list.json is defined
    - coolify_key_uuid == ""

- name: Create Private Key in Coolify if missing
  block:
    - name: Post Private Key to Coolify API
      ansible.builtin.uri:
        url: "{{ coolify_api_base_url }}/security/keys"
        method: POST
        headers:
          Authorization: "Bearer {{ coolify_api_token }}"
          Content-Type: "application/json"
        body_format: json
        body:
          name: "{{ coolify_key_name }}"
          description: "Managed by Ansible"
          private_key: "{{ coolify_private_key_content }}"
        status_code: [201]
      register: create_key_result
  rescue:
    - name: Diagnostic - Investigate Private Key validation failure
      ansible.builtin.shell: |
        docker exec -e KEY_CONTENT="$KEY_CONTENT" coolify php artisan tinker --execute='
        $keyContent = getenv("KEY_CONTENT");
        $name = "{{ coolify_key_name }}";
        
        try {
            $res = openssl_pkey_get_private($keyContent);
            if ($res === false) {
                echo "OPENSSL_ERROR: " . openssl_error_string() . "\n";
                if (str_contains($keyContent, "OPENSSH PRIVATE KEY")) {
                    echo "SUGGESTION: This is an OPENSSH format key. Coolify might require RSA/PEM format. Try converting it with: ssh-keygen -p -m PEM -f your_key\n";
                }
            } else {
                echo "OPENSSL_OK. Checking for naming conflicts...\n";
                $exists = \App\Models\PrivateKey::where("name", $name)->exists();
                if ($exists) {
                    echo "NAME_EXISTS: " . $name . "\n";
                } else {
                    echo "UNKNOWN_API_FAILURE. Key is valid according to OpenSSL and name is free.\n";
                }
            }
        } catch (\Exception $e) {
            echo "TINKER_EXCEPTION: " . $e->getMessage() . "\n";
        }
        '
      register: key_diag
      environment:
        KEY_CONTENT: "{{ coolify_private_key_content }}"
      changed_when: false
      ignore_errors: true

    - name: Fail with detailed information
      ansible.builtin.fail:
        msg: |
          Failed to register private key in Coolify.
          API Error: {{ ansible_failed_result.json.message | default(ansible_failed_result.msg) }}
          Diagnostic: {{ key_diag.stdout | default('No diagnostic output') }}
          Key Info Error: {{ (key_info | default({})).stderr | default('None') }}
          Key Type Output: {{ (key_info | default({})).stdout | default('Unknown') }}
          Conversion Result: {{ (conversion_result | default({})).rc | default('skipped') }}
          Key format starts with: {{ coolify_private_key_content[:30] }}
  when: 
    - not ansible_check_mode
    - coolify_key_uuid == ""
    - coolify_private_key_content is defined
    - coolify_private_key_content.startswith('-----BEGIN')

- name: Set key UUID from creation result
  ansible.builtin.set_fact:
    coolify_key_uuid: "{{ create_key_result.json.uuid if create_key_result.json.uuid is defined else create_key_result.json }}"
  when: 
    - not ansible_check_mode
    - create_key_result is defined
    - create_key_result.json is defined

- name: Fallback to 'default' key UUID if preferred not found
  ansible.builtin.set_fact:
    coolify_key_uuid: "{{ (keys_list.json | selectattr('name', 'equalto', 'default') | first).uuid if keys_list is not skipped and keys_list.json is defined and (keys_list.json | selectattr('name', 'equalto', 'default') | list | length > 0) else coolify_key_uuid }}"
  when: 
    - not ansible_check_mode
    - coolify_key_uuid == ""

- name: Fallback to first available key UUID
  ansible.builtin.set_fact:
    coolify_key_uuid: "{{ keys_list.json[0].uuid if keys_list is not skipped and keys_list.json is defined and keys_list.json | length > 0 else coolify_key_uuid }}"
  when: 
    - not ansible_check_mode
    - coolify_key_uuid == ""

- name: Set Public Key fact
  ansible.builtin.set_fact:
    coolify_public_key: "{{ (keys_list.json | selectattr('uuid', 'equalto', coolify_key_uuid) | first).public_key if keys_list.json is defined and (keys_list.json | selectattr('uuid', 'equalto', coolify_key_uuid) | list | length > 0) else '' }}"
  when: 
    - not ansible_check_mode
    - coolify_key_uuid != ""

- name: Re-fetch keys if newly created to get public key
  ansible.builtin.uri:
    url: "{{ coolify_api_base_url }}/security/keys"
    method: GET
    headers:
      Authorization: "Bearer {{ coolify_api_token }}"
  register: keys_list_after_create
  when: 
    - not ansible_check_mode
    - create_key_result is changed
    - coolify_public_key == ""

- name: Set Public Key fact after creation
  ansible.builtin.set_fact:
    coolify_public_key: "{{ (keys_list_after_create.json | selectattr('uuid', 'equalto', coolify_key_uuid) | first).public_key }}"
  when: 
    - not ansible_check_mode
    - keys_list_after_create is defined
    - keys_list_after_create.json is defined

- name: Save Coolify public key to local state folder
  ansible.builtin.copy:
    content: "{{ coolify_public_key }}"
    dest: "{{ coolify_state_path }}/{{ inventory_hostname }}/backups/coolify/{{ coolify_key_name }}.pub"
    mode: '0644'
  delegate_to: localhost
  become: false
  when:
    - not ansible_check_mode
    - coolify_public_key is defined
    - coolify_public_key != ""

- name: Debug key info
  ansible.builtin.debug:
    msg: "Using Private Key UUID: {{ coolify_key_uuid }} with Public Key: {{ coolify_public_key | default('NOT FOUND') }}"

- name: Add Coolify public key to controller authorized_keys
  ansible.posix.authorized_key:
    user: root
    state: present
    key: "{{ coolify_public_key }}"
  when:
    - not ansible_check_mode
    - coolify_public_key is defined
    - coolify_public_key != ""
