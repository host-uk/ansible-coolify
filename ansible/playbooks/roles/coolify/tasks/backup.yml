---
- name: Ensure backup directory exists on local machine
  ansible.builtin.file:
    path: "{{ playbook_dir }}/../backups/{{ inventory_hostname }}/reinstall"
    state: directory
    mode: '0700'
  delegate_to: localhost
  become: false

- name: Setup API for backup trigger
  ansible.builtin.include_tasks: api_setup.yml
  when: inventory_hostname == 'vm-controller'

- name: Trigger manual schedule run on vm-controller
  ansible.builtin.command: docker exec coolify php artisan schedule:run-manual
  register: schedule_run
  changed_when: true
  when: inventory_hostname == 'vm-controller'

- name: Wait for backup completion
  ansible.builtin.pause:
    seconds: 2
  when: inventory_hostname == 'vm-controller'

- name: Get latest backup info via Tinker
  ansible.builtin.shell: |
    docker exec coolify php artisan tinker --execute='
    $execution = \Illuminate\Support\Facades\DB::table("scheduled_database_backup_executions")
        ->latest()
        ->first();
    if ($execution) {
        echo json_encode($execution);
    } else {
        echo "null";
    }
    '
  register: tinker_backup_info
  until: 
    - tinker_backup_info.stdout != "null"
    - (tinker_backup_info.stdout | from_json).status == 'success'
  retries: 10
  delay: 5
  when: 
    - inventory_hostname == 'vm-controller'
  ignore_errors: true

- name: Debug Backup Info
  ansible.builtin.debug:
    var: tinker_backup_info.stdout
  when: 
    - inventory_hostname == 'vm-controller'
    - tinker_backup_info.stdout is defined

- name: Find latest Coolify instance backup file
  ansible.builtin.find:
    paths: /data/coolify/backups/instance
    patterns: "*.tar.gz"
    recurse: no
  register: coolify_instance_backups
  when: inventory_hostname == 'vm-controller'

- name: Fetch Coolify instance backup
  ansible.builtin.fetch:
    src: "{{ (coolify_instance_backups.files | sort(attribute='mtime', reverse=true) | first).path }}"
    dest: "{{ playbook_dir }}/../backups/{{ inventory_hostname }}/reinstall/"
    flat: true
  when: 
    - inventory_hostname == 'vm-controller'
    - coolify_instance_backups.matched > 0
  ignore_errors: true

- name: Get APP_KEY from .env
  ansible.builtin.shell: grep '^APP_KEY=' /data/coolify/source/.env | cut -d'=' -f2-
  register: app_key_raw
  changed_when: false

- name: Save APP_KEY for later
  ansible.builtin.copy:
    content: "{{ app_key_raw.stdout }}"
    dest: "{{ playbook_dir }}/../backups/{{ inventory_hostname }}/reinstall/APP_KEY"
    mode: '0600'
  delegate_to: localhost
  become: false

- name: Create database dump
  ansible.builtin.shell: |
    docker exec coolify-db pg_dump -U coolify -d coolify -Fc > /tmp/coolify_db.dump
  register: db_dump
  changed_when: true

- name: Fetch database dump
  ansible.builtin.fetch:
    src: /tmp/coolify_db.dump
    dest: "{{ playbook_dir }}/../backups/{{ inventory_hostname }}/reinstall/coolify_db.dump"
    flat: true

- name: Archive SSH keys
  ansible.builtin.shell: |
    cd /data/coolify/ssh/keys && tar -czf /tmp/coolify_ssh_keys.tar.gz .
  register: ssh_keys_archive
  changed_when: true

- name: Fetch SSH keys archive
  ansible.builtin.fetch:
    src: /tmp/coolify_ssh_keys.tar.gz
    dest: "{{ playbook_dir }}/../backups/{{ inventory_hostname }}/reinstall/coolify_ssh_keys.tar.gz"
    flat: true

- name: Remove temporary files on remote
  ansible.builtin.file:
    path: "{{ item }}"
    state: absent
  loop:
    - /tmp/coolify_db.dump
    - /tmp/coolify_ssh_keys.tar.gz
